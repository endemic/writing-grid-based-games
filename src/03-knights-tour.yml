title: Game #3: Knight's Tour
author: Nathan Demick
description: Make a "Knight's Tour" game with GridJS
content: |
  https://en.wikipedia.org/wiki/Knight%27s_tour

  I learned about Knight's Tour from [Steve Wozniak's autobiograhy](https://en.wikipedia.org/wiki/IWoz). He made a hardware version of the game when he was still a student, which I found pretty amazing. The basic gist is that a player tries to move a single chess knight to each square on an 8x8 chess board, but you can only land on each square once. The challenge comes from the wonky movement rules of the knight, which means you can get stuck pretty easily. Well, you had me at "8x8 chess board" &mdash; that's a grid! We can easily make a web version of this game by using a 2D array to keep track of the game's data.

  Download the [grid.js starter template](), then edit `scripts/game.js` to create that 8x8 grid. The one bit of extra logic we'll run here is to fill the grid with alternating black & white tiles, in order to make it look like a chess board.

  ```javascript
  class Game extends Grid {
    constructor() {
      super(rows = 8, columns = 8);

      let nextState = this.currentState;

      // simple helper function to determine if a number is even or odd
      const isEven = number => number % 2 === 0;

      // make the grid look like a chessboard, with alternating white/black tiles
      for (let y = 0; y < this.rows; y += 1) {
        for (let x = 0; x < this.columns; x += 1) {
          nextState[x][y] = isEven(x + y) ? 'white' : 'black';
        }
      }

      Grid.update(nextState);
    }
  }
  ```

  Add the following CSS rules to the main stylesheet. Download a copy of [`knight.png`]() and put it in the `images` folder. Reload the page to see the chessboard pattern.

  ```css
  body {
    align-items: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  #grid {
    width: 75%;
  }

  .white { background: white; }
  .black { background: black; }
  .visited { background: limegreen; }
  .knight { background: url('../images/knight.png') center/100%; }
  ```

  In order to handle interaction, we need to set up an event listener in the `constructor` method. We only care about when the player clicks or taps the grid itself, not the rest of the page, so we can attach the event listener directly on the grid.

  ```javascript
  const grid = document.querySelector('#grid');

  grid.addEventListener('click', event => this.onClick(event));
  ```

  This event listener is referencing an `onClick` method in the `Game` class, which hasn't actually been written yet. We'll add a minimal implementation just to make sure that user interaction is working as expected. Add a definition for `onClick` after the `constructor`:

  ```javascript
  onClick(event) {
    const clicked = {
      x: parseInt(event.target.dataset.x, 10),
      y: parseInt(event.target.dataset.y, 10)
    };

    console.log(`Clicked (${x}, ${y})`);
  }
  ```

  The `Grid` class that is used for the base of this game is fairly simple, but one of the things it does is fill an HTML element (that has `id="grid"`) with rows and columns of `<div>` elements, which represent the grid. When these `<div>`s are created, they are assigned `x` and `y` properties based on their position, which makes it easy to find out which cell was clicked/touched. We can access those properties on the event object that is generated by the browser when an interaction takes place. In this case, `event.target` points to the HTML element that was clicked. `dataset` is a way to get access to any `data` properties on that element &mdash; if you inspect the source of the HTML file that embeds our game using the developer tools, you'll see the `<div>`s inside the grid look something like `<div data-x="3" data-y="4"></div>`. Save and reload the game in your browser, then click around the grid with the developer console open &mdash; you should see log messages indicating which cell was clicked.

  Now that basic interactivity has been hooked up, we can start looking at game logic. For this implementation of the game, we'll let the player choose their own starting point, which means the first click will place the knight piece. We can keep track of the knight's position by using an instance variable that will be persisted in memory, as long as the page is not reloaded.

  ```javascript
  // `onClick`
  let nextState = this.currentState;

  knight = clicked;

  // draw the knight on the grid
  nextState[knight.x][knight.y] = 'knight';

  Grid.update(nextState);
  ```

  This code will place the knight wherever the player clicks. Reload and click around &mdash; you should be able to create knight pieces. Kinda cool, but this isn't exactly the functionality that we want, which is to have a single knight move around the board. Let's update `onClick` so that when a new cell is clicked, the knight moves there, and the previous cell is marked as "visited" (the idea being that you can't land on the same spot twice).

  ```javascript
  // `onClick`
  let nextState = this.currentState;

  // handle condition for first move -- you can start anywhere
  if (!knight) {
    knight = clicked;
  } else {
    // mark the old spot as "visited"
    nextState[knight.x][knight.y] = 'visited';

    // move the knight to the new spot
    knight = clicked;

    // draw the knight on the grid
    nextState[knight.x][knight.y] = 'knight';
  }

  Grid.update(nextState);
  ```

  Alright, more progress. Now there is only a single knight that can move around the board. But we still need to program in more game logic: the knight can't land on any "visited" spaces, and has to move like it does in the game of chess (two forward, one to the side). The first condition is simple to implement: check the value of the clicked cell to see if it is `visited` or not.

  ```javascript
  // `onClick`
  let nextState = Grid.currentState;

  // handle condition for first move -- you can start anywhere
  if (!knight) {
    knight = clicked;
  // can't move to any visited space
  } else if (nextState[clicked.x][clicked.y] !== 'visited') {
    // mark the old spot as "visited"
    nextState[knight.x][knight.y] = 'visited';

    // move the knight to the new spot
    knight = clicked;
  } else {
    console.log(`(${clicked.x}, ${clicked.y}) was already visited!`);
  }

  // draw the knight on the new spot
  nextState[knight.x][knight.y] = 'knight';

  Grid.update(nextState);
  ```

  The movement rule shouldn't be too hard to program in either. Given the current (x, y) position of the knight, we can generate a list of allowable spaces by adding or subtracting from the knight's location. For example, we can create an array of `{x, y}` objects that represent valid moves:

  ```javascript
  const {x, y} = knight;

  const allowedMoves = [
    // above
    { x: x - 1, y: y - 2},
    { x: x + 1, y: y - 2},

    // left
    { x: x - 2, y: y - 1},
    { x: x - 2, y: y + 1},

    // right
    { x: x + 2, y: y - 1},
    { x: x + 2, y: y + 1},

    // below
    { x: x - 1, y: y + 2},
    { x: x + 1, y: y + 2},
  ];
  ```

  So what we need to do is check if the `allowedMoves` array contains (x, y) values that are equal to the `clicked` object.

  ```javascript
  // `onClick`
  let nextState = this.currentState;

  // handle condition for first move -- you can start anywhere
  if (!knight) {
    knight = clicked;
  // can't move to any visited space
  } else if (nextState[clicked.x][clicked.y] !== 'visited') {
    const {x, y} = knight;
    const allowedMoves = [
      // above
      { x: x - 1, y: y - 2},
      { x: x + 1, y: y - 2},

      // left
      { x: x - 2, y: y - 1},
      { x: x - 2, y: y + 1},

      // right
      { x: x + 2, y: y - 1},
      { x: x + 2, y: y + 1},

      // below
      { x: x - 1, y: y + 2},
      { x: x + 1, y: y + 2},
    ];

    // check if clicked.x/clicked.y match any of the allowed moves
    // if so, the spot the user clicked is valid!
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
    let valid = allowedMoves.some(({x, y}) => x === clicked.x && y === clicked.y);

    if (valid) {
      // mark the old spot as "visited"
      nextState[knight.x][knight.y] = 'visited';

      // move the knight to the new spot
      knight = clicked;
    } else {
      console.log(`(${clicked.x}, ${clicked.y}) is an invalid move!`);
    }
  } else {
    console.log(`(${clicked.x}, ${clicked.y}) was already visited!`);
  }

  // draw the knight on the grid
  nextState[knight.x][knight.y] = 'knight';

  Grid.update(nextState);
  ```

  The core functionality and logic of the game are now complete. The last feature we'll add is a function to check if the player has "won," by visiting all 64 squares on the board. At the end of the game, there will be no more moves left, because each square in our grid will have a value of `visited`, except for the last square which will have the knight. So to check for a win condition, we iterate over the game board and check that only those two values are present.

  ```javascript
  const wonGame = () => {
    const state = Grid.currentState;

    for (let y = 0; y < Grid.rows; y += 1) {
      for (let x = 0; x < Grid.columns; x += 1) {
        if (state[x][y] !== 'visited' && state[x][y] !== 'knight') {
          return false;
        }
      }
    }

    // if we've made it here, then the entire grid has been visited,
    // and the knight is in the last square
    return true;
  }
  ```

  This method can then be used at the very end of the `onClick` method, to display a message to the player if they manage to finish the game.

  ```javascript
  // at the end of `onClick`

  Grid.update(nextState);

  if (wonGame()) {
    alert('Congratulations!');
  }
  ```

  That's it! If you get stuck, [download a copy of the completed project]() and compare it with what you've typed in.

  ### Exercises left for the reader

  1. Keep score: increment a point counter whenever the player makes a successful move
  2. Reset: add a button to the page that resets the game, rather than making the player reload the page
  3. Beginner mode: update the game board to highlight allowed next moves
