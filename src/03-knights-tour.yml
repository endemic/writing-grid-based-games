title: Game &#35;3&#58; Knight's Tour
author: Nathan Demick
description: Make a "Knight's Tour" game with GridJS
content: |
  https://en.wikipedia.org/wiki/Knight%27s_tour

  I learned about Knight's Tour from [Steve Wozniak's autobiograhy](https://en.wikipedia.org/wiki/IWoz). He made a hardware version of the game when he was still a student, which I found pretty amazing. The basic gist is that a player tries to move a single chess knight to each square on an 8x8 chess board, but you can only land on each square once. The challenge comes from the wonky movement rules of the knight, which means you can get stuck pretty easily. Well, you had me at "8x8 chess board" &mdash; that's a grid! We can easily make a web version of this game by using a 2D array to keep track of the game's data.

  [Download grid.js](https://github.com/endemic/gridjs/releases/tag/v1.0.1), then edit `game.js` to create that 8x8 grid. The one bit of extra logic we'll run here is to fill the grid with alternating black and white tiles, in order to make it look like a chess board. Add the lines with a `+` in front, and remove lines prefixed by a `-`:

  <pre><code class="language-diff-javascript diff-highlight">- const rows = 10;
  - const columns = 10;
  + const rows = 8;
  + const columns = 8;

  Grid.init(rows, columns);

  - Grid.onKeyDown(({ key }) => {
  -   console.log(`pressed ${key}`);
  - });

  + let nextState = Grid.currentState;
  +
  + // simple helper function to determine if a number is even or odd
  + const isEven = number => number % 2 === 0;
  +
  + // make the grid look like a chessboard, with alternating white/black tiles
  + for (let y = 0; y < rows; y += 1) {
  +   for (let x = 0; x < columns; x += 1) {
  +     nextState[x][y] = isEven(x + y) ? 'white' : 'black';
  +   }
  + }
  +
  + Grid.update(nextState);

  Grid.onPointDown(({ x, y }) => {
    //...</code></pre>

  Add the following CSS rules to the end of `main.css`:

  <pre><code class="language-diff-css diff-highlight">  .highlight {
      background-color: blueviolet;
    }
  }
  +
  + body {
  +   align-items: center;
  +   display: flex;
  +   flex-direction: column;
  +   justify-content: center;
  + }
  +
  + #grid {
  +   width: 50%;
  + }
  +
  + .white { background: white; }
  + .black { background: black; }
  + .visited { background: limegreen; }
  + .knight { background: url('knight.png') center/100%; }</code></pre>

  Download a copy of [`knight.png`](assets/knights-tour/knight.png) and put it in same folder as the rest of the GridJS files. Save the `game.js` and `main.css` files, and load `index.html` in your browser (**File &rarr; Open File &rarr; index.html**). You should see a page that displays a grid with a chessboard pattern.

  <figure>
    <img src="assets/knights-tour/example_1.png" alt="image of chess board grid">
    <figcaption>the chess board!</figcaption>
  </figure>

  We now need to handle user interactions. GridJS has a helper for this called `onPointDown` &mdash; this function will run a callback whenever the player clicks or touches the touchscreen. The code included in the `game.js` file already has an example of how this helper can be used; we're going to delete some of that code and write our own. For this game, we'll let the player choose their own starting point, which means the first click will place the knight piece. We can keep track of the knight's position by using a local variable named, appropriately enough, `knight`.

  <pre><code class="language-diff-javascript diff-highlight">+ let knight;
  +
  Grid.onPointDown(({ x, y }) => {
    console.debug(`clicked grid cell (${x}, ${y})`);

  -   /* replace this with your own code! */
    const nextState = Grid.currentState;

  +   // save the knight's position
  +   knight = {x, y};
  +
  +   // draw the knight on the grid
  +   nextState[knight.x][knight.y] = 'knight';
  +
  -   if (Grid.isEmpty(nextState[x][y])) {
  -     nextState[x][y] = 'highlight';
  -   } else {
  -     nextState[x][y] = '';
  -   }
  -
    Grid.update(nextState);
  });
  </code></pre>

  Save `game.js` and reload your browser. Now, click around on the grid &mdash; you should be able to create knight pieces in each cell.

  <figure>
    <img src="assets/knights-tour/example_2.png" alt="placing knight pieces on the chess board">
    <figcaption>placing knight pieces on the chess board</figcaption>
  </figure>

  Kinda cool, but this isn't exactly the functionality that we want, which is to have a single knight move around the board. Let's update the code so that when a cell is clicked, the knight moves there, and the previous cell is marked as "visited" (the idea being that you can't land on the same spot twice).

  <pre><code class="language-diff-javascript diff-highlight">Grid.onPointDown(({ x, y }) => {
    console.debug(`clicked grid cell (${x}, ${y})`);

    const nextState = Grid.currentState;

  + // if the knight has already been placed on the grid...
  + if (knight) {
  +   // draw the current position as "visited"
  +   nextState[knight.x][knight.y] = 'visited';
  + }

    // save the knight's position
    knight = {x, y};

    // draw the knight on the grid
    nextState[knight.x][knight.y] = 'knight';

    Grid.update(nextState);
  });
  </code></pre>

  More progress! Now there is only a single knight that can move around the board.

  <figure>
    <img src="assets/knights-tour/example_3.png" alt="moving a single knight piece on the chess board">
    <figcaption>moving a single knight piece on the chess board</figcaption>
  </figure>

  But we still need to program in more game logic: the knight can't land on any "visited" spaces, and has to move like it does in the game of chess (two forward, one to the side). The first condition is simple to implement: check the value of the clicked cell to see if it is `visited` or not. If it is, then we just `return` early and don't execute the rest of the function.

  <pre><code class="language-diff-javascript diff-highlight">Grid.onPointDown(({ x, y }) => {
    console.debug(`clicked grid cell (${x}, ${y})`);

    const nextState = Grid.currentState;

  + if (nextState[x][y] === 'visited') {
  +   console.log(`(${clicked.x}, ${clicked.y}) was already visited!`);
  +   return;
  + }

    // if the knight has already been placed on the grid...
    if (knight) {
        // draw the current position as "visited"
        nextState[knight.x][knight.y] = 'visited';
    }

    // set the new knight position
    knight = {x, y};

    // draw on the grid
    nextState[knight.x][knight.y] = 'knight';

    Grid.update(nextState);
  });
  </code></pre>

  The movement rule shouldn't be too hard to add in either. Given the current **(x, y)** position of the knight, we can generate a list of allowable spaces by adding or subtracting from the knight's location. For example, we can create an array of `{x, y}` objects that represent valid moves:

  <pre><code class="language-diff-javascript diff-highlight">const {x, y} = knight;

  const allowedMoves = [
    // above
    { x: x - 1, y: y - 2},
    { x: x + 1, y: y - 2},

    // left
    { x: x - 2, y: y - 1},
    { x: x - 2, y: y + 1},

    // right
    { x: x + 2, y: y - 1},
    { x: x + 2, y: y + 1},

    // below
    { x: x - 1, y: y + 2},
    { x: x + 1, y: y + 2},
  ];
  </code></pre>

  If you're a visual person, like me, you could imagine the `allowedMoves` array looks something like this, with `K` being the knight, and `x` being a valid move:

  <pre><strong>[ ][x][ ][x][ ]
  [x][ ][ ][ ][x]
  [ ][ ][K][ ][ ]
  [x][ ][ ][ ][x]
  [ ][x][ ][x][ ]</strong></pre>

  So what we need to do is check if the `allowedMoves` array contains (x, y) values that are equal to where the player clicked.

  <pre><code class="language-diff-javascript diff-highlight">
  // `onClick`
  let nextState = this.currentState;

  // handle condition for first move -- you can start anywhere
  if (!knight) {
    knight = clicked;
  // can't move to any visited space
  } else if (nextState[clicked.x][clicked.y] !== 'visited') {
    const {x, y} = knight;
    const allowedMoves = [
      // above
      { x: x - 1, y: y - 2},
      { x: x + 1, y: y - 2},

      // left
      { x: x - 2, y: y - 1},
      { x: x - 2, y: y + 1},

      // right
      { x: x + 2, y: y - 1},
      { x: x + 2, y: y + 1},

      // below
      { x: x - 1, y: y + 2},
      { x: x + 1, y: y + 2},
    ];

    // check if clicked.x/clicked.y match any of the allowed moves
    // if so, the spot the user clicked is valid!
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
    let valid = allowedMoves.some(({x, y}) => x === clicked.x && y === clicked.y);

    if (valid) {
      // mark the old spot as "visited"
      nextState[knight.x][knight.y] = 'visited';

      // move the knight to the new spot
      knight = clicked;
    } else {
      console.log(`(${clicked.x}, ${clicked.y}) is an invalid move!`);
    }
  } else {
    console.log(`(${clicked.x}, ${clicked.y}) was already visited!`);
  }

  // draw the knight on the grid
  nextState[knight.x][knight.y] = 'knight';

  Grid.update(nextState);
  </code></pre>

  The core functionality and logic of the game are now complete. The last feature we'll add is a function to check if the player has "won," by visiting all 64 squares on the board. At the end of the game, there will be no more moves left, because each square in our grid will have a value of `visited`, except for the last square which will have the knight. So to check for a win condition, we iterate over the game board and check that only those two values are present.

  <pre><code class="language-diff-javascript diff-highlight">
  const wonGame = () => {
    const state = Grid.currentState;

    for (let y = 0; y < Grid.rows; y += 1) {
      for (let x = 0; x < Grid.columns; x += 1) {
        if (state[x][y] !== 'visited' && state[x][y] !== 'knight') {
          return false;
        }
      }
    }

    // if we've made it here, then the entire grid has been visited,
    // and the knight is in the last square
    return true;
  }
  </code></pre>

  This method can then be used at the very end of the `onClick` method, to display a message to the player if they manage to finish the game.

  <pre><code class="language-diff-javascript diff-highlight">
  // at the end of `onClick`

  Grid.update(nextState);

  if (wonGame()) {
    alert('Congratulations!');
  }
  </code></pre>

  That's it! If you get stuck, [download a copy of the completed project]() and compare it with what you've typed in.

  ### Exercises left for the reader

  1. Keep score: increment a point counter whenever the player makes a successful move
  2. Reset: add a button to the page that resets the game, rather than making the player reload the page
  3. Beginner mode: update the game board to highlight allowed next moves
