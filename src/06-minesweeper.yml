title: Game #5: Minesweeper
author: Nathan Demick
description: Make a "Minesweeper" game with Waffle
content: |
  One of the classic time-wasting games that lots of people have fond memories of is Minesweeper; particularly the [Microsoft version](https://en.wikipedia.org/wiki/Microsoft_Minesweeper). Since it was included in Windows 3.1, it was one of those games that you could always count on when you might have access to an unfamiliar PC. Although, I have a personal confession: I always played Solitaire or Hearts, rather than Minesweeper. I never took the time to really learn how to play the game! Nevertheless, Minesweeper is a classic example of a grid-based game, and one that is a great candidate for re-implementing yourself.

  As far as the rules go, the game is actually pretty simple. You've got a grid, with randomly placed "mines." The mines are hidden by an overlay. Clicking one of the hidden grid cells will reveal what's underneath. If it's a mine, you lose. If it's a number, that means there are that many mines in the eight neighboring spaces. If it's blank, then all neighboring blank spaces are revealed. The gist is to try to reveal the game state by logically using the clues.

  Making a version of Minesweeper with Waffle uses two grid "layers." The first grid is what's actually displayed to the player -- basically storing which "unknown" spaces have been clicked. The second grid stores the location of the mines and hints. For a simple 5x5 game board, the following is a representation of what the `mines` grid would look like.

  ```
  [1][1][1][ ][ ]
  [1][*][2][ ][ ]
  [1][2][*][1][ ]
  [ ][1][1][2][1]
  [ ][ ][ ][1][*]
  ```

  We'll start by making a 10x10 version of the game; increasing the board size can be left as an exercise for the reader. The first step is to [download Waffle](https://github.com/endemic/waffle/releases/latest) and open up `main.css`. We'll go ahead and add graphics for the various game objects that we plan to use in the game.

  <pre><code class="language-diff-css diff-highlight">#grid {
    /* ... */

  -  .highlight {
  -    background-color: blueviolet;
  -  }

  + .unknown { background-image: url('images/unknown.png'); }
  + .mine { background-image: url('images/mine.png'); }
  + .empty { background-image: url('images/empty.png'); }
  + .one { background-image: url('images/one.png'); }
  + .two { background-image: url('images/two.png'); }
  + .three { background-image: url('images/three.png'); }
  + .four { background-image: url('images/four.png'); }
  + .five { background-image: url('images/five.png'); }
  + .six { background-image: url('images/six.png'); }
  }</code></pre>


  Now that these CSS classes have been defined, we can set the value of a grid cell to `five` (for example), and have the associated image file show up in the right place. So what we'll do now is set up the two grids for the game, the "visual" grid (to show the current state of the game) and the "data" grid (holds locations of mines and hints).

  We can set up the data grid after the call to `Waffle.init`; we can copy the 10x10 grid used by the visual grid, and overwrite its values. We'll start by randomly placing some mines in the grid, by writing the value `mine` to the appropriate grid index. This code chooses a random point in the grid, and tries to put a mine there. If that point already has something in it, we loop until we find an empty space.

  <pre><code class="language-diff-javascript diff-highlight">Waffle.init(rows, columns);

  + const mines = Waffle.state;

  + // more mines == harder
  + const mineCount = 10;

  + // randomly place the mines
  + for (let i = 0; i < mineCount; i += 1) {
  +   let p = Waffle.randomPoint;

  +   while (!Waffle.isEmpty(mines[p.x][p.y])) {
  +     p = Waffle.randomPoint;
  +   }

  +   mines[p.x][p.y] = 'mine';
  + }
  </code></pre>

  Now that the mines have been placed, we can generate the numeric hints. If an open space has any mines next to it, we count them up and put that number in the space. They'll let the player logically deduce where the mines are.

  <pre><code class="language-diff-javascript diff-highlight">// mine placement code redacted
    mines[p.x][p.y] = 'mine';
  }

  + for (let y = 0; y < rows; y += 1) {
  +   for (let x = 0; x < columns; x += 1) {

  +     // Skip cells that contain mines
  +     if (mines[x][y] === 'mine') {
  +       continue;
  +     }

  +     // Find the number of mines contained in neighboring cells
  +     const count = Waffle.getNeighbors({ x, y }, true)     // positions of 8 surrounding spaces
  +                       .filter(({ x, y }) => mines[x][y] === 'mine') // keep the spaces that have mines
  +                       .length;                                          // count how many there are
  +
  +     const hints = ['empty','one','two','three','four','five','six'];
  +
  +     // now we can store the hint string; aka how many mines surround the square
  +     mines[x][y] = hints[count];
  +   }
  + }</code></pre>

  The mine grid is now complete. Next we'll set up the visual grid &mdash; when the game first starts, no mines have been revealed yet, so all the squares displayed to the player can be marked as `unknown`.

  <pre><code class="language-diff-javascript diff-highlight">    // hint placement code redacted
      mines[x][y] = hints[count];
    }
  }

  + // initialize the visual grid with `unknown`
  + Waffle.fill('unknown');
  </code></pre>

  The game state has now been completely initialized. Next we need to handle user input. To do that we'll replace the code in the `Waffle.onPointDown` handler that runs whenever the player taps or clicks the grid.

  <pre><code class="language-diff-javascript diff-highlight">
  Waffle.onPointDown(({x, y}) => {
    if (mineState[x][y] === 'mine') {
      // u lose
    }

    const state = Waffle.state;

    reveal({x, y}, state);

    Waffle.state = nextState;

    if (hasWonGame()) {
      // u win
    }
  });
  </code></pre>

  const reveal = ({x, y}, state) {
    // if this space has already been revealed, then stop
    if (state !== 'unknown') {
      return;
    }

    // reveal the space using the "mines" grid
    state[x][y] = mines[x][y];

    // if this space is a hint, then stop
    if (state[x][y] !== 'empty') {
      return;
    }

    // otherwise, since the cell is empty, we check
    // all 8 neighbors for more empty cells
    const includeDiagonals = true;
    Waffle.getNeighbors({ x, y }, includeDiagonals).forEach(neighbor => {
      reveal(neighbor, state);
    });
  };

  const hasWonGame = () => {
    const state = Waffle.state;

    // search through state for unrevealed cells;
    // note the inverted loops
    for (let y = 0; y < Waffle.rows; y += 1) {
      for (let x = 0; x < Waffle.columns; x += 1) {
        const value = ;

        // if cell doesn't have a mine, and is still unrevealed
        if (state[x][y] === 'unknown' && mines[x][y] !== 'mine') {
          return false;
        }
      }
    }

    return true;
  };
