title: Game #6: Sokoban
author: Nathan Demick
description: Make a "Sokoban" game with GridJS
content: |
  [Sokoban](https://en.wikipedia.org/wiki/Sokoban) is yet another classic casual game genre. You control a player who must organize boxes by pushing them to certain locations. The difficulty is to not get a box stuck by pushing it against the wall or into a corner. As a kid, I played games with similar mechanics, such as [Rodent's Revenge](https://en.wikipedia.org/wiki/Rodent's_Revenge). These sorts of games are easily made with GridJS, as they limit movement to within a grid in each level. Let's go ahead and figure out how to make a basic sokoban game.

  As always, [download the GridJS source](https://github.com/endemic/gridjs/releases/latest), which has a `game.js` template file with some example code.

  1. Draw walls
  2. Draw player
  3. Player movement
  4. Draw boxes/goals
  5. Move boxes
  6. Win condition/reset

  ```javascript
  const rows = 10;
  const columns = 10;

  Grid.init(rows, columns);

  // hard code the level
  const level = [
    ['#','#','#','#','#',' ',' ',' ',' ',' '],
    ['#','@',' ',' ','#',' ','#','#','#',' '],
    ['#',' ','B','B','#',' ','#','x','#',' '],
    ['#',' ','B',' ','#',' ','#','x','#',' '],
    ['#','#','#',' ','#','#','#','x','#',' '],
    [' ','#','#',' ',' ',' ',' ',' ','#',' '],
    [' ','#',' ',' ',' ','#',' ',' ','#',' '],
    [' ','#',' ',' ',' ','#','#','#','#',' '],
    [' ','#','#','#','#','#',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' ',' ',' ',' '],
  ];

  const player = {x: 0, y: 0};

  // gridjs is so simple that it doesn't have a way to persist overlapping
  // objects. The moving object overwrites whatever was there previously. In sokoban,
  // this is a problem because both the player and boxes can move over top of box targets,
  // which need to re-appear if the player or box moves back off again. Therefore, we need
  // to store the location of targets in a separate data structure instead of just in `Grid.state`
  const targets = [];

  const nextState = Grid.state;

  for (let x = 0; x < Grid.columns; x += 1) {
    for (let y = 0; y < Grid.rows; y += 1) {
      // note the reversed order of x and y
      // allows us to have a 2d array that looks the same in the code
      const cell = level[y][x];

      // evaluate the simplifed text contents of the level
      // and set the state of the grid
      switch (cell) {
        case 'B':
          nextState[x][y] = 'box';
          break;
        case '#':
          nextState[x][y] = 'wall';
          break;
        case 'x':
          nextState[x][y] = 'target';
          targets.push({x, y});
          break;
        case '@':
          nextState[x][y] = 'player';
          player.x = x;
          player.y = y;
          break;
      }
    }
  }

  Grid.state = nextState;

  Grid.onKeyDown(({ key }) => {
    const move = {x: 0, y: 0};

    switch (key) {
      case 'w':
        move.y -= 1;
        break;
      case 's':
        move.y += 1;
        break;
      case 'a':
        move.x -= 1;
        break;
      case 'd':
        move.x += 1;
        break;
    }

    const playerNext = {
      x: player.x + move.x,
      y: player.y + move.y
    };

    const state = Grid.state;

    // TODO: not sure this makes things clearer; uses scope access of `state` variable
    const movePlayer = (destination) => {
      // remove the player from the old position
      state[player.x][player.y] = '';

      // update location data
      player.x = destination.x;
      player.y = destination.y;

      // put player in new position
      state[player.x][player.y] = 'player';
    };

    if (canMoveTo(playerNext)) {
      movePlayer(playerNext);
    } else if (state[playerNext.x][playerNext.y] === 'box') {

      // figure out if the box is blocked or not
      const boxNext = {
        x: playerNext.x + move.x,
        y: playerNext.y + move.y
      };

      if (canMoveTo(boxNext)) {
        // move the box
        state[boxNext.x][boxNext.y] = 'box';

        // the player will overwrite the box's previous position
        movePlayer(playerNext);
      } else {
        console.log(`Can't move box; blocked by ${state[boxNext.x][boxNext.y]}`);
      }
    }

    // ensure targets are re-displayed if player/box moves off them
    for (const t of targets) {
      if (Grid.isEmpty(state[t.x][t.y])) {
        state[t.x][t.y] = 'target';
      }
    }

    Grid.state = state;

    if (hasWonGame()) {
      alert('u win');
    }
  });

  const canMoveTo = (point) => {
    const state = Grid.state;

    return Grid.isEmpty(state[point.x][point.y]) || state[point.x][point.y] === 'target';
  };

  const hasWonGame = () => {
    const state = Grid.state;

    return targets.every(t => state[t.x][t.y] === 'box');
  };
  ```
