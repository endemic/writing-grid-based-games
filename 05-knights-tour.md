---
layout: post
status: draft
title: "Grid-based game tutorial: Knight's Tour"
author:
  display_name: Nathan
  email: n@demick.org
date: 2023-09-11 10:21:38 -0400
categories:
- games
comments: []
---

https://en.wikipedia.org/wiki/Knight%27s_tour

I learned about Knight's Tour from Steve Wozniak's autobiograhy. The basic gist is that the player tries to move a single chess knight to each square on an 8x8 chess board, but you can only land on each square one time. The challenge being that the wonky movement rules of the knight means you can get stuck pretty easily. Well, you had me at "8x8 chess board" &mdash; that's a grid! We can easily make a web version of this game by using a 2D array to keep track of the game's data.

Download the [grid.js starter template](), then edit `scripts/game.js` to create that 8x8 grid. The one bit of extra logic we'll run here is to fill the grid with alternating black & white tiles, in order to make it look like a chess board.

```javascript
class Game extends Grid {
  constructor() {
    super(rows = 8, columns = 8);

    let nextState = this.currentState;

    // simple helper function to determine if a number is even or odd
    const isEven = number => number % 2 === 0;

    // make the grid look like a chessboard, with alternating white/black tiles
    for (let y = 0; y < this.rows; y += 1) {
      for (let x = 0; x < this.columns; x += 1) {
        nextState[x][y] = isEven(x + y) ? 'white' : 'black';
      }
    }

    this.render(nextState);
  }
}
```

Add the following CSS rules to the main stylesheet. Download a copy of `knight.png` here. Reload the page to see the chessboard pattern.

```css
.white { background: white; }
.black { background: black; }
.visited { background: grey; }
.knight { background: url('../images/knight.png') center/100%; }
```

In order to handle interaction, we need to set up an event listener in the `constructor` method. We only care about when the player clicks or taps the grid itself, not the rest of the page, so we can attach the event listener directly on the grid.

```javascript
const grid = document.querySelector('#grid');

grid.addEventListener('click', event => this.onClick(event));
```

This event listener is referencing an `onClick` method in the `Game` class, which hasn't actually been written yet. We'll add a minimal implementation just to make sure that user interaction is working as expected. Add a definition for `onClick` after the `constructor`:

```javascript
onClick(event) {
  const clicked = {
    x: parseInt(event.target.dataset.x, 10),
    y: parseInt(event.target.dataset.y, 10)
  };

  console.log(`Clicked (${x}, ${y})`);
}
```

The `Grid` class that is used for the base of this game is fairly simple, but one of the things it does is fill an HTML element (that has `id="grid"`) with rows and columns of `<div>` elements, which represent the grid. When these `<div>`s are created, they are assigned `x` and `y` properties based on their position, which makes it easy to find out which cell was clicked/touched. We can access those properties on the event object that is generated by the browser when an interaction takes place. In this case, `event.target` points to the HTML element that was clicked. `dataset` is a way to get access to any `data` properties on that element &mdash; if you inspect the source of the HTML file that embeds our game using the developer tools, you'll see the `<div>`s inside the grid look something like `<div data-x="3" data-y="4"></div>`. Save and reload the game in your browser, then click around the grid with the developer console open &mdash; you should see log messages indicating which cell was clicked.

Now that basic interactivity has been hooked up, we can start looking at game logic. For this implementation of the game, we'll let the player choose their own starting point, which means the first click will place the knight piece. We can keep track of the knight's position by using an instance variable that will be persisted in memory, as long as the page is not reloaded.

```javascript
// `onClick`
let nextState = this.currentState;

this.knight = clicked;

// draw the knight on the grid
nextState[this.knight.x][this.knight.y] = 'knight';

this.render(nextState);
```

This code will place the knight wherever the player clicks. Reload and click around. Kinda cool, but this isn't exactly the functionality that we want, which is to have a single knight move around the board. Let's update `onClick` so that when a new cell is clicked, the knight moves there, and the previous cell is marked as "visited" (the idea being that you can't land on the same spot twice).

```javascript
// `onClick`
let nextState = this.currentState;

// handle condition for first move -- you can start anywhere
if (!this.knight) {
  this.knight = clicked;
} else {
  // mark the old spot as "visited"
  nextState[this.knight.x][this.knight.y] = 'visited';

  // move the knight to the new spot
  this.knight = clicked;
}

this.render(nextState);
```

Alright, more progress. Now there is only a single knight that can move around the board. But we still need to program in more game logic: the knight can't land on any "visited" spaces, and has to move like it does in the game of chess (two forward, one to the side). The first condition is simple to implement: check the value of the clicked cell to see if it is `visited` or not.

```javascript
// `onClick`
let nextState = this.currentState;

// handle condition for first move -- you can start anywhere
if (!this.knight) {
  this.knight = clicked;
// can't move to any visited space
} else if (nextState[clicked.x][clicked.y] !== 'visited') {
  // mark the old spot as "visited"
  nextState[this.knight.x][this.knight.y] = 'visited';

  // move the knight to the new spot
  this.knight = clicked;
} else {
  console.log(`(${clicked.x}, ${clicked.y}) was already visited!`);
}

this.render(nextState);
```

The movement rule shouldn't be too hard to program in either. Given the current (x, y) position of the knight, we can generate a list of allowable spaces by adding or subtracting from the knight's location. For example, we can create an array of `{x, y}` objects that represent valid moves:

```javascript
const {x, y} = this.knight;

const allowedMoves = [
  // above
  { x: x - 1, y: y - 2},
  { x: x + 1, y: y - 2},

  // left
  { x: x - 2, y: y - 1},
  { x: x - 2, y: y + 1},

  // right
  { x: x + 2, y: y - 1},
  { x: x + 2, y: y + 1},

  // below
  { x: x - 1, y: y + 2},
  { x: x + 1, y: y + 2},
];
```

So all we need to do is check if the `allowedMoves` array contains (x, y) values that are equal to the `clicked` object.

```javascript
// `onClick`
let nextState = this.currentState;

// handle condition for first move -- you can start anywhere
if (!this.knight) {
  this.knight = clicked;
// can't move to any visited space
} else if (nextState[clicked.x][clicked.y] !== 'visited') {
  const {x, y} = this.knight;
  const allowedMoves = [
    // above
    { x: x - 1, y: y - 2},
    { x: x + 1, y: y - 2},

    // left
    { x: x - 2, y: y - 1},
    { x: x - 2, y: y + 1},

    // right
    { x: x + 2, y: y - 1},
    { x: x + 2, y: y + 1},

    // below
    { x: x - 1, y: y + 2},
    { x: x + 1, y: y + 2},
  ];

  // check if clicked.x/clicked.y match any of the allowed moves
  // if so, the spot the user clicked is valid!
  let valid = allowedMoves.some(({x, y}) => x === clicked.x && y === clicked.y);

  if (valid) {
    // mark the old spot as "visited"
    nextState[this.knight.x][this.knight.y] = 'visited';

    // move the knight to the new spot
    this.knight = clicked;
  } else {
    console.log(`(${clicked.x}, ${clicked.y}) is an invalid move!`);
  }
} else {
  console.log(`(${clicked.x}, ${clicked.y}) was already visited!`);
}

this.render(nextState);
```

Exercises for the reader

1. Keep score: increment a point counter whenever the player makes a successful move
2. Reset: add a button to the page that resets the game, rather than making the player reload the page
3. Beginner mode: update the game board to highlight allowed next moves
