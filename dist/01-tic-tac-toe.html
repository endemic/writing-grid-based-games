<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Game &#35;1&#58; Tic-Tac-Toe | Ganbaru Games</title>
    
    <meta name="description" content="A simple game of tic-tac-toe using gridjs">
    <meta name="author" content="Nathan Demick">

    <meta property="og:title" content="Game &#35;1&#58; Tic-Tac-Toe" />
    <meta property="og:description" content="A simple game of tic-tac-toe using gridjs" />

    <link rel="stylesheet" href="https://ganbaru.games/assets/stylesheets/main.css">
    <link rel="shortcut icon" href="https://ganbaru.games/assets/images/henohenomoheji.png" type="image/png">

    <link rel="stylesheet" href="stylesheets/prism.css">
    <link rel="stylesheet" href="stylesheets/extra.css">
  </head>
  <body>
    <h1><span class="henohenomoheji"></span>Ganbaru Games</h1>

    <div class="container">
      <h2>Game &#35;1&#58; Tic-Tac-Toe</h2>

      <section class="text">
        <p>One of the simplest games you can play on a grid is tic-tac-toe: mark spaces in a 3x3 grid with <em>X</em> or <em>O</em>; the player who gets three in a row (horizontally, vertically, or diagonally) wins. Let’s program a simple version of the game using GridJS. This will give a good introduction to some recurring concepts that you can use to build other games in the future.</p>

<p>First, <a href="https://github.com/endemic/gridjs/releases">download GridJS</a>, which includes an <code>index.html</code> file that automatically loads the necessary JavaScript and CSS files. Next, open the <code>game.js</code> file in a text editor; you’ll see that there is some example code there already which initializes a 10x10 grid, and sets up a simple event listener to toggle grid cell background colors. The first thing we can do is change the grid size to a 3x3 board.</p>

<pre><code class="language-diff-javascript diff-highlight">- const rows = 10;
- const columns = 10;
+ const rows = 3;
+ const columns = 3;

Grid.init(rows, columns);</code></pre>

<p>For this version of the game, we’ll keep things simple — on an empty game board, the first click (or tap) on an empty square will place an <em>X</em>, the second will place an <em>O</em>, and so on. The example code already has set up a <code>click</code> event listener on the game board that gets the Cartesian coordinates (x, y) of the clicked space. We can modify this code slightly to place <em>X</em> and <em>O</em> graphics.</p>

<pre><code class="language-diff-javascript diff-highlight">Grid.init(rows, columns);

+ // start by placing "X"
+ let player = 'x';

Grid.onPointDown(({ x, y }) =&gt; {
-   console.debug(`clicked grid cell (${x}, ${y})`);

-   /* replace this with your own code! */
  const nextState = Grid.state;

+   // do nothing if a player clicks on a square that's already filled
+   if (!Grid.isEmpty(nextState[x][y])) {
+     return;
+   }
+   
+   nextState[x][y] = player;

-   if (Grid.isEmpty(nextState[x][y])) {
-      nextState[x][y] = 'highlight';
-   } else {
-     nextState[x][y] = '';
-   }

-   if (Grid.isEmpty(nextState[x][y])) {
-     nextState[x][y] = player;
-   }

  Grid.state = nextState;
});</code></pre>

<p>If you save the <code>game.js</code> file and load <code>index.html</code> in a browser (<strong>File → Open File → index.html</strong>), you should see a 3x3 grid in the center of the page. However, clicking squares inside doesn’t seem to do anything. That’s because GridJS uses CSS classes to apply styling to each square. The page looks for a class style of <code>.x</code> inside of <code>main.css</code>, but it’s not there. Let’s add it now. Make your own graphic files to represent an <em>X</em> and <em>O</em>, or else download some samples <a href="assets/tic-tac-toe/images.zip">here</a>. Then add the following at the bottom of <code>main.css</code>:</p>

<pre><code class="language-diff-css diff-highlight">#grid {
  /* ... */

-  .highlight {
-    background-color: blueviolet;
-  }

+  .x { background: url('x.png') center/100%; }
+  .o { background: url('o.png') center/100%; }
}</code></pre>

<p>These background rules specify the image file that should be used for the background, and that the image should be placed in the center of the element, and take up 100% of the available background space. Save and reload, then click the grid — you should start seeing _X_s appear. However, it’t not actually a game of tic-tac-toe yet, since the second player needs to be able to add marks to the board. We can make this happen by toggling the value of the <code>player</code> variable between <code>x</code> and <code>o</code>. After the call to <code>Grid.update(nextState)</code>, add the following condition:</p>

<pre><code class="language-diff-javascript diff-highlight">Grid.state = nextState;

+ // switch players
+ if (player === 'x') {
+   player = 'o';
+ } else {
+   player = 'x';
+ }</code></pre>

<p>Now, when you click or tap an empty square, either an <em>X</em> or <em>O</em> will be placed there. We’re getting close! The last part of the game is to check to see if a player has won, or whether it has ended in a tie. If we think about the grid in terms of Cartesian coordinates, it might look something like this:</p>

<pre><code>(0, 0) | (1, 0) | (2, 0)
------------------------
(0, 1) | (1, 1) | (2, 1)
------------------------
(0, 2) | (1, 2) | (2, 2)
</code></pre>

<p>In total, there are eight ways to win: fill in a column (3), a row (3), or one of the diagonals (2). We can make a list of each of these valid win conditions, and then loop through the list, checking the value of each square in the grid.</p>

<pre><code class="language-diff-javascript diff-highlight">Grid.state = nextState;

+ const winPositions = [
+   [{x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}], // row 1
+   [{x: 0, y: 1}, {x: 1, y: 1}, {x: 2, y: 1}], // row 2
+   [{x: 0, y: 2}, {x: 1, y: 2}, {x: 2, y: 2}], // row 3
+ 
+   [{x: 0, y: 0}, {x: 0, y: 1}, {x: 0, y: 2}], // column 1
+   [{x: 1, y: 0}, {x: 1, y: 1}, {x: 1, y: 2}], // column 2
+   [{x: 2, y: 0}, {x: 2, y: 1}, {x: 2, y: 2}], // column 3
+ 
+   [{x: 0, y: 0}, {x: 1, y: 1}, {x: 2, y: 2}], // diagonal 1
+   [{x: 0, y: 2}, {x: 1, y: 1}, {x: 2, y: 0}], // diagonal 2
+ ];
+ 
+ for (const group of winPositions) {
+   let winner;
+ 
+   if (group.every(square =&gt; nextState[square.x][square.y] === 'x')) {
+     winner = 'X';
+   } else if (group.every(square =&gt; nextState[square.x][square.y] === 'o')) {
+     winner = 'O';
+   }
+ 
+   if (winner) {
+     alert(`Player "${winner}" wins!`);
+   }
+ }

// switch players
if (player === 'x') {</code></pre>

<p>Put this code block right before the condition that swaps player turns. This should correctly identify when one player has won.</p>

<p>There’s another end game state, however, and that’s when all squares in the board have been filled in — a tie game. Checking for this state is a bit easier than determining the “win” condition: we need to check each square in the board, and if each is filled (without a player having already won) then the game is tied.</p>

<pre><code class="language-diff-javascript diff-highlight">  if (winner) {
    alert(`Player "${winner}" wins!`);
  }
}

+ // start with the assumption that all squares have been used
+ let tieGame = true;
+
+ for (let x = 0; x &lt; columns; x += 1) {
+   for (let y = 0; y &lt; rows; y += 1) {
+     // if we find any empty square, it means the game isn't over yet
+     if (Grid.isEmpty(nextState[x][y])) {
+       tieGame = false;
+     }
+   }
+ }
+
+ if (tieGame) {
+   alert('Tie game!');
+ }

// switch players
if (player === 'x') {</code></pre>

<p>One last feature we can implement is a way to programatically reset the game, so that you can keep playing without reloading the page (which re-initializes all the JavaScript code). A way to do this is keep track of whether the game is considered “over” by using a boolean variable. The next time a player clicks on the game board after the game is over will trigger some code to reset the game. Add the boolean right after the local variable used to store the current player.</p>

<pre><code class="language-diff-javascript diff-highlight">let player = 'x';
+ let gameOver = false;

Grid.onPointDown(({ x, y }) =&gt; {</code></pre>

<p>We now need to set that variable to <code>true</code> if one player wins, or if the game is tied.</p>

<pre><code class="language-diff-javascript diff-highlight">if (wonGame) {
  alert(`Player "${player}" wins!`);

+ gameOver = true;
}</code></pre>

<pre><code class="language-diff-javascript diff-highlight">if (tieGame) {
  alert('Tie game!');

+ gameOver = true;
}</code></pre>

<p>Finally, add a block in the <code>onPointDown</code> handler to check if the game is over, and if so, reset.</p>

<pre><code class="language-diff-javascript diff-highlight">Grid.onPointDown(({ x, y }) =&gt; {
+ if (gameOver) {
+   // reset the game
+   gameOver = false;
+   player = 'x';
+   Grid.fill('');
+   return;
+ }

  const nextState = Grid.state;</code></pre>

<p>And that’s it! You’ve created a version of tic-tac-toe that’s playable via a web browser. If the game doesn’t work as you expect, you can download the <a href="assets/tic-tac-toe/example.zip">completed project source</a> and compare with what you’ve written. This sets the stage for making more complicated games in the future.</p>

<h3 id="postscript">Postscript</h3>

<p>You may notice that when an <code>alert</code> window pops up after clicking a square on the grid, you don’t actually see the square update with an <em>X</em> or <em>O</em> until <em>after</em> you click “OK.” This is because <code>alert</code> windows stop any other code from running until it is dismissed. A dumb hack you can use to get around this is delay the <code>alert</code> until after existing code has been run, by using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout">setTimeout</a>:</p>

<pre><code class="language-javascript">const delayedAlert = message =&gt; {
  setTimeout(() =&gt; {
    alert(message);
  }, 0);
};</code></pre>

<p>Since the delay is <code>0</code>, the alert basically runs immediately, but it waits until any existing code is finished executing. Now replace all your calls to <code>alert</code> with <code>delayedAlert</code>, and you’ll see the UI update before the alert message appears.</p>

      </section>

    </div>  <!-- /.container -->

    <!-- syntax highlighting -->
    <script src="scripts/prism.js"></script>

    <section id="about">
      <p>
        Ganbaru Games publishes games written by
        <a href="https://nathandemick.com" title="Nathan Demick">Nathan Demick</a>.
        Each game is playable mobile and desktop web browsers.
        In fact, you can load a game, then "save to homescreen" on your
        smartphone to have convenient access at any time!
      </p>

      <p>
        <a style="float: right;" href="https://ko-fi.com/I2I7LV8YU" target="_blank">
          <img height="36" style="border:0px;height:36px;" src="https://storage.ko-fi.com/cdn/kofi5.png?v=3" alt="Buy Me a Coffee at ko-fi.com">
        </a>
      </p>

      <ul>
        <li><a href="https://github.com/endemic/gridjs">Game making resources</a></li>
        <li><a href="mailto:support@ganbarugames.com">Contact</a></li>
        <li><a href="/privacy.html" title="Privacy Policy">Privacy Policy</a></li>
      </ul>
    </section>

    <footer>
      &copy; 2025 Ganbaru Games, LLC.
    </footer>
  </body>
</html>
